<h1>Adaptive</h1>

<h2>Description</h2>
<p>
  Цель этой страницы продемонстрировать возможности всех миксинов из файла
  <pupa-code-inline>adaptive.scss</pupa-code-inline>. Каждый из этих миксинов применяется при условиях совпадения
  разрешению окна. Для демонстрации работоспособности примеров&nbsp;—&nbsp;делайте ресайз окна.
</p>

<h2>Mixins</h2>

<p>Базовые миксины, которые настраивают адаптивное отображение.</p>

<h3>
  @mixin width-between($min-width, $max-width)
  <br />
  @mixin height-between($min-height, $max-height)
</h3>
<p>
  Стили применятся только в рамках указанных границ. Ниже представлен пример, когда для всех ширин окна отображается
  квадрат, кроме ширин, лежащих в интервале <pupa-code-inline>[1500, 1599]</pupa-code-inline>. А также блок станет
  красного цвета, если высота окна находится в интервале <pupa-code-inline>[800, 899]</pupa-code-inline>
</p>

<pupa-code-container [content]="example1Content">
  <demo-adaptive-example-1></demo-adaptive-example-1>
</pupa-code-container>

<h3>
  @mixin width-less-than($width)
  <br />
  @mixin height-less-than($height)
  <br />
  @mixin width-more-than($width)
  <br />
  @mixin height-more-than($height)
</h3>

<p>Стили применятся, если ширина/высота меньше/больше указанного значения. В примере ниже:</p>
<ul>
  <li>Квадрат станет кругом, если ширина окна меньше 900;</li>
  <li>Блок станет в 2 раза больше, если ширина окна больше (или равна) 1500;</li>
  <li>Блок станет красным, если высота окна меньше 900;</li>
  <li>Блок примет градиентную заливку, если высота окна больше (или равна) 1000;</li>
</ul>

<pupa-code-container [content]="example2Content">
  <demo-adaptive-example-2></demo-adaptive-example-2>
</pupa-code-container>

<h3>
  @mixin portrait()
  <br />
  @mixin landscape()
</h3>

<p>
  Это миксины, которые помогают ловить ориентацию устройства. В примере ниже в горизонтальной ориентации
  блок&nbsp;—&nbsp;это красный квадрат, а для вертикальной ориентации&nbsp;—&nbsp;это синий круг.
</p>
<pupa-code-container [content]="example3Content">
  <demo-adaptive-example-3></demo-adaptive-example-3>
</pupa-code-container>

<br />
<h2>Grid Mixins</h2>
<p>
  Ниже будут приводиться примеры использования миксинов, построенных на сетке. Что такое сетка, зачем она нужна, какие
  есть согласованные брейкопоинты и отступы можно прочитать
  <a href="https://bimeister.atlassian.net/wiki/spaces/BIMeister/pages/1196065866" target="_blank">здесь</a>. Активный
  брейкпоинт выставляется как класс для тега <pupa-code-inline>html</pupa-code-inline>. Сетку можно включить через
  <pupa-code-inline>toggle grid</pupa-code-inline>.
</p>

<h3>@mixin xs(), @mixin sm(), @mixin md(), @mixin lg(), @mixin xlg(), @mixin xl(), @mixin xxl()</h3>

<p>Для каждого из этих миксинов стили применятся, только для указанного брейкпоинта. В примере ниже:</p>
<ul>
  <li>Для <b>xs</b>&nbsp;—&nbsp;блок красный</li>
  <li>Для <b>sm</b>&nbsp;—&nbsp;блок желтый</li>
  <li>Для <b>md</b>&nbsp;—&nbsp;блок синий</li>
  <li>Для <b>lg</b>&nbsp;—&nbsp;блок зеленый</li>
  <li>Для <b>xlg</b>&nbsp;—&nbsp;блок прозрачный, граница красная</li>
  <li>Для <b>xl</b>&nbsp;—&nbsp;блок прозрачный, граница желтая</li>
  <li>Для <b>xxl</b>&nbsp;—&nbsp;блок прозрачный, граница зеленая</li>
</ul>

<pupa-code-container [content]="example4Content">
  <demo-adaptive-example-4></demo-adaptive-example-4>
</pupa-code-container>

<h3>@mixin lt-sm(), @mixin lt-md(), @mixin lt-lg(), @mixin lt-xlg(), @mixin lt-xl(), @mixin lt-xxl()</h3>

<p>
  Имена этого набора миксинов&nbsp;—&nbsp; сокращения от названия
  <pupa-code-inline>less than {{ '${' }}breakpoint{{ '}' }}</pupa-code-inline
  >. То есть стили будут применяться для всех разрешений меньших брейкпоинта, указанного в названии миксина.
  <b>Не включая сам брейкпоинт</b>. Исходя из этого, стоит обратить внимание, что миксин
  <pupa-code-inline>lt-sm()</pupa-code-inline> равносилен миксину <pupa-code-inline>xs()</pupa-code-inline>. Приведем
  пример использования лишь одного миксина из этого набора. В примере ниже квадрат станет кругом для всех брейкопоинтов
  меньших <b>xlg</b>.
</p>

<p>
  Такие миксины стоит использовать для более точечной настройки адаптивности. Пример из практики: есть дровер
  фиксированной ширины. Но мы хотим, чтобы его ширина была <pupa-code-inline>100vw</pupa-code-inline> для всех
  брейкпоинтов, меньших <b>lg</b>, чтобы иметь корректное представление для мобильных/планшетных устройств.
</p>

<pupa-code-container [content]="example5Content">
  <demo-adaptive-example-5></demo-adaptive-example-5>
</pupa-code-container>

<h3>@mixin gt-sm(), @mixin gt-md(), @mixin gt-lg(), @mixin gt-xlg(), @mixin gt-xl(), @mixin gt-xxl()</h3>

<p>
  Имена этого набора миксинов&nbsp;—&nbsp; сокращения от названия
  <pupa-code-inline>greater than {{ '${' }}breakpoint{{ '}' }}</pupa-code-inline
  >. То есть стили будут применяться для всех разрешений больших брейкпоинта, указанного в названии миксина.
  <b>Не включая сам брейкпоинт</b>. В примере ниже квадрат станет кругом для всех брейкопоинтов больших <b>lg</b>.
</p>

<pupa-code-container [content]="example6Content">
  <demo-adaptive-example-6></demo-adaptive-example-6>
</pupa-code-container>

<p><b>Использовать только для верхнеуровневой верстки. То есть только для верстки скелета самой страницы</b></p>

<h3>
  @mixin grid-size($xs, $sm, $md, $lg, $xlg, $xl, $xxl, $property: 'width')
  <br />
  @mixin grid-offset($xs, $sm, $md, $lg, $xlg, $xl, $xxl, $property: 'margin-left')
  <br />
  @mixin grid-container-offset($property: 'padding-left')
  <br />
  @mixin grid-container()
</h3>

<p>Эти миксины без вложенного контента.</p>

<p>
  Миксин <pupa-code-inline>grid-size</pupa-code-inline> устанавливает сколько колонок занимает элемент на каждом
  брейкпоинте. Последним аргументом является передаваемое свойство. Его можно настраивать по необходимости. По умолчанию
  это <pupa-code-inline>width</pupa-code-inline>.
</p>

<p>
  Миксин <pupa-code-inline>grid-offset</pupa-code-inline> устанавливает сколько колонок должен отступить элемент на
  каждом брейкпоинте. Последним аргументом является передаваемое свойство. Его можно настраивать по необходимости. По
  умолчанию это <pupa-code-inline>margin-left</pupa-code-inline>.
</p>

<p>
  Миксин <pupa-code-inline>grid-container-offset</pupa-code-inline> устанавливает отступ контейнера от края страницы.
  Сам отступ берется из согласованного конфига. Последним аргументом является передаваемое свойство. Его можно
  настраивать по необходимости. По умолчанию это <pupa-code-inline>padding-left</pupa-code-inline>.
</p>

<p>
  Миксин <pupa-code-inline>grid-container</pupa-code-inline> это собирательный миксин для удобства. Он устанавливает
  отступы от края страницы из конфига слева и справа (через миксин
  <pupa-code-inline>grid-container-offset</pupa-code-inline> со свойствами
  <pupa-code-inline>padding-left</pupa-code-inline> и
  <pupa-code-inline>padding-right</pupa-code-inline> соответственно). Добавляет позиционирование флексом и другие
  базовые стили для контейнера.
</p>

<p>
  Вcя дизайн-система PupaKit заадптирована через эти миксины. Например, для меню (сайдбар) указано правило: сколько
  колонок оно занимает на каждом конкретном брейкпоинте. А основной контент придерживается правилу отступа на ширину
  сайдбара. Отобразите сетку, чтобы увидеть это.
</p>

<pupa-code-container [isPreviewExist]="false" [content]="example7Content"></pupa-code-container>

<h2>CSS locks / СSS шлюзы</h2>

<p>
  Это специальные миксины и функции, которые позволяют применить математику css-шлюзов для пропорционального увеличения
  размерностей.
</p>

<h3>
  @function calc-between-width(...)
  <br />
  @function calc-between-height(...)
  <br />
  @mixin width-between-property(...)
  <br />
  @mixin height-between-property(...)
</h3>

<p>
  Функции <pupa-code-inline>calc-between-width(...)</pupa-code-inline> и
  <pupa-code-inline>calc-between-height(...)</pupa-code-inline> рассчитывают пропорциональную размерность в пикселях. Ее
  можно выставить любому свойству, которое поддерживает размерность в пикселях. Математика в них выглядит следующим
  образом:
</p>

<pupa-code-fetch [codeFilePath]="example8CalcBetweenScssPath"></pupa-code-fetch>

<p>
  Миксины <pupa-code-inline>width-between-property(...)</pupa-code-inline> и
  <pupa-code-inline>height-between-property(...)</pupa-code-inline> внутри себя используют функции выше и присваивают
  значение переданному свойству. У этих миксинов есть флажки
  <pupa-code-inline>$is-save-width-before</pupa-code-inline> и
  <pupa-code-inline>$is-save-width-after</pupa-code-inline>, которые позволяют сохранить утановленное значение после
  выхода за пределы указанного интервала.
</p>

<p>
  В примере ниже есть 6 блоков содержаших текст. Первые 3 реагируют на изменения ширины окна, последние 3&nbsp;—&nbsp;на
  изменение высоты. В каждом из этих кейсов первый блок реагирует только в указанном интервале. Второй блок сохраняет
  значение после интервала. Третий блок&nbsp;—&nbsp;сохраняет значение после интервала.
</p>

<pupa-code-container [content]="example8Content">
  <demo-adaptive-example-8></demo-adaptive-example-8>
</pupa-code-container>

<h3>
  @function grid-column($columnsCount, $gutter, $breakpointWidth)
  <br />
  @function grid-column-offset($columnCount, $gutter, $breakpointWidth)
</h3>

<p>
  Эти функции вспомогательные для миксинов <pupa-code-inline>grid-size</pupa-code-inline> и
  <pupa-code-inline>grid-offset</pupa-code-inline>. Они рассчитывают размеры/отступы контейнера на каждом брейпоинте в
  зависимости от количества колонок и отстпупов.
</p>

<h2>Other</h2>

<h3>@mixin hover()</h3>

<p>
  На десктопных разрешениях у нас есть мышка. А значит есть и ховер-состояние. Состояние, когда навелись мышкой на
  элемент. На это состояние можно повесить определенные стили. Но как бы мы этого не хотели, придется смириться с тем,
  что ховер состояния проскакивают и на мобильных девайсах, даже при логичном условии, что нет там никакой мышки. Перед
  самым <pupa-code-inline>tap</pupa-code-inline>-ом по элементу моргает hover-состояние, что выглядит "нехорошо". Чтобы
  этого избежать можно использовать миксин <pupa-code-inline>hover()</pupa-code-inline>. Он включит стиль наведения
  только на тех разрешениях, где действительно есть ховер.
</p>

<p>
  В примере ниже, когда наведемся на блок он станет красным. Но на мобильных устройствах как бы мы не кликали по
  блоку&nbsp;—&nbsp;ховер состояние не проскочит. Для демонстрации результата второй блок использует обычный
  <pupa-code-inline>:hover</pupa-code-inline>. Когда по нему кликать на мобльном устройсте, можно увидеть
  ховер-состояние.
</p>

<p>Чтобы увидеть это&nbsp;—&nbsp;включите режим мобльного отображения в <b>DevTools</b>.</p>

<pupa-code-container [content]="example9Content">
  <demo-adaptive-example-9></demo-adaptive-example-9>
</pupa-code-container>

<h3>TypeScript</h3>

<p>
  Со стилями все понятно. Через миксины можем отслеживать любое состояние окна и делать в зависимости от этих
  ограничений свои стили. Но иногда нужно поймать состояние окна в ts. Что делать в таких случаях? Для этих целей в
  PupaKit можно использовать <pupa-code-inline>ClientUiStateHandlerService</pupa-code-inline>. В стриме
  <pupa-code-inline>uiState$</pupa-code-inline> можно найти всю необходимую информацию, в том числе об активном
  брейкпоинте. BIMeister также ловит это состояние и записывает в стейт <pupa-code-inline>UiState</pupa-code-inline>.
</p>

<h3>Touch Events</h3>

<p>
  Не открою тайну, если скажу, что событие клика на мобильных устройствах намного более долгое, чем событие тапа. Чтобы
  улучшить отклик интерфейса для этих целей добавили библиотеку <b>hammer.js</b> в PupaKit и Bimeister. Используя
  <pupa-code-inline>(tap)</pupa-code-inline> можно улучшить отклик. На десктнопных девайсах
  <pupa-code-inline>(tap)</pupa-code-inline> отработает как <pupa-code-inline>(click)</pupa-code-inline>. В этой
  библиотеке собрано еще множество тач-событий, найти их всех можно
  <a href="https://hammerjs.github.io/" target="_blank">здесь</a>.
</p>
